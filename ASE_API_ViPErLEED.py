# -*- coding: utf-8 -*-
"""A collection of functions that run ViPErLEED from a provided ASE object.

@Author: Alexander M. Imre
based on tleedm_from_ase.py by Florian Kraushofer
"""


import sys
import os
import numpy as np
import shutil
import ase.db
import lzma, base64

import viperleed

# for refcalc_from_ase_structure
from viperleed.tleedm import run_tleedm
from viperleed.tleedmlib import Slab, Rparams
from viperleed.tleedmlib.files.poscar import writePOSCAR
# for run_rfactor_from_csv
from viperleed.tleedmlib.files.beams import readOUTBEAMS
from viperleed.tleedmlib.files.iorfactor import beamlist_to_array
from viperleed.tleedmlib.wrapped.rfactor import r_factor_new as rf
from viperleed.tleedmlib.wrapped.error_codes import error_codes

def refcalc_for_ase_structure(exec_path,
                              ase_object = None,
                              cut_symmetric_cell_height_fraction = 0.4, use_which_part_of_cell="keep_above", flip_cell_in_z=False,
                              switch_b_c = False,
                              uc_transformation_matrix = None, uc_isotropic_scaling = None):
    """
    inputs_path: TODO
    exec_path: Path where to execute the reference calculation
    ase_object: ase type object that contains the slab for use with ViPErLEED
    cut_symmetric_cell_height_fraction: float, where to cut the ase object cell (ViPErLEED can not use symmetric cells)
    use_which_part_of_cell: string, wether to keep the part above or below cut_symmetric_cell_height_fraction (use "keep_above" or "keep_below")
    flip_cell_in_z: bool, wether to flip in z direction (useful in case the lower part of a symmetric cell is kept
    uc_transformation_matrix: 3x3 np array, can contain an arbitray scaling and rotation that will be applied to the cell
    uc_isotropic_scaling: float, isotropic scaling of the cell. Can be used to e.g. quickly change the lattice constant in a cubic cell.
    """

    # check the provided path

    if not os.path.isdir(exec_path):
        # Invalid path given
        raise RuntimeError("Provided path is invalid")

    # check for PARAMETERS file
    parameters_name = "PARAMETERS"
    if not os.path.isfile(os.path.join(exec_path, parameters_name)):
        # No PARAMETERS file – Error
        raise RuntimeError("No PARAMETERS file found – this is required")

    # Copy all files in the input Path (or just PARAMETERS, VIBROCC, IVBEAMS, PHASESHIFTS, ... ) TODO
    
    # If present, we are good to go.
    # Files IVBEAMS, PHASESHIFTS and VIBROCC are not required and can be autogenerated

    # Run parameters object: dummy but needed for getSurfaceAtoms
    rp = Rparams()

    # Transfer ASE object into slab object for ViPErLEED
    slab = Slab(ase_atoms=ase_object)
    
    # TODO. docstring conforming to numpy standard
    

    # Transformation of slab object: Rotation or isotropic streching/shrinking
    if uc_transformation_matrix is not None:
        if uc_isotropic_scaling is not None:
            raise RuntimeError("Transformation matrix and isotropic scaling provided. These are mutually exclusive.")
        slab.apply_matrix_transformation(uc_transformation_matrix)
    elif uc_isotropic_scaling is not None:
        slab.apply_isotropic_scaling(uc_isotropic_scaling)


    # Cut the symmetric slab in half so we can work with just the surface
    # Remove everything below cut_fraction
    if (use_which_part_of_cell=="keep_above"):
        slab.atlist = [at for at in slab.atlist if at.pos[2] > cut_symmetric_cell_height_fraction]
    elif (use_which_part_of_cell=="keep_below"):
        slab.atlist = [at for at in slab.atlist if at.pos[2] < cut_symmetric_cell_height_fraction]
    else:
        raise RuntimeError("use_which_part_of_cell must be either 'keep_above' or 'keep_below'")

    slab.updateAtomNumbers()
    slab.updateElementCount()

    # Figure out surface sites
    site_def = {}
    surface_atoms = slab.getSurfaceAtoms(rp)
    # surface species of each element
    for el in slab.elements:
        atn = [at.oriN for at in surface_atoms if at.el == el]
        if atn:
            site_def[el] = {'surf': atn}


    poscar_name = "POSCAR"
    if os.path.isfile(os.path.join(exec_path, poscar_name)):
        raise RuntimeError("A 'POSCAR' file is already present in directory.")
    writePOSCAR(slab, "POSCAR")


    # Take care of input files and work directory
    work_path = os.path.abspath(os.path.join(exec_path, "work"))
    os.makedirs(work_path, exist_ok=True)
    # copy input files to work directory
    # NOTE: PARAMETERS should NOT contain SITE_DEF flags.
    # VIBROCC should contain *_surf sites for all elements.
    for file in ['PARAMETERS', 'VIBROCC', 'IVBEAMS', 'PHASESHIFTS', 'DISPLACEMENTS', 'EXPBEAMS', 'EXPBEAMS.csv']:
        try:
            shutil.copy2(os.path.join(exec_path, file), os.path.join(work_path, file))
        except FileNotFoundError:
            pass


    home = os.path.abspath('.')
    os.chdir(work_path)

    
    # We are ready to run ViPErLEED! Have fun!
    run_tleedm(slab=slab, preset_params={'SITE_DEF': site_def},
               source=os.path.dirname(viperleed.__file__))

    # ViPErLEED should have suceeded if you arrive here!

    # read out the THEOBEAMS.csv file and complex ampliudes:
    theobeams_name = 'THEOBEAMS.csv'
    amp_real_name = 'Complex_amplitudes_real.csv'
    amp_imag_name = 'Complex_amplitudes_imag.csv'

    with open(theobeams_name) as f:
        theobeams_file_str = f.read()
    with open(amp_real_name) as f:
        amp_real_file_str = f.read()
    with open(amp_imag_name) as f:
        amp_imag_file_str = f.read()

    # Move back home           
    os.chdir(home)


    return (theobeams_file_str, amp_real_file_str, amp_imag_file_str)


def run_rfactor_from_csv(beams_file1, beams_file2, V0i, V0r_shift_range=[-3,3], intpol_deg=5, intpol_step=0.5):
    """A function that compute the Pendry R-factor between two CSV files as produced and used by ViPErLEED
    
    vpr_src_path: Path to the ViPErLEED source code
    beams_file1, beams_file2: Path to the two CSV files for R-factor calculation. These can contain theoretical or experimental beams.
    V0i: float, imaginary part of the inner potential (eV)
    V0r_shift_range: float, During R-factor calculation, the real part of the inner potential is varied within these bounds (eV). It is recommended to choose multiples of intpol_step as bounds.
    intpol_deg: int, either 3 or 5, Degree of the interpolating spline polynomial
    intpol_step: float, step size of the energy grid the beam data will be interpolated on (eV).
    """
    # It makes sense for the V0r_shift_range to be a multiple of intpol_step, but this neither strictly required nor enforced
    
    # use Pendry R-factor
    which_r = 1
    
    err_msg = ""
    
    # check if string or Path object TODO
    # TODO run from passed string object
    beams1 = readOUTBEAMS(beams_file1)
    beams2 = readOUTBEAMS(beams_file2)
    
    
    # Check common beams:
    beam1_has_correspondece = [False]*len(beams1)
    beam2_correspondence = [None]*len(beams2)

    for i, beam1 in enumerate(beams1):
        for j, beam2 in enumerate(beams2):
            if _comp_beam_index(beam1.hkfrac, beam2.hkfrac):
                beam1_has_correspondece[i] = True
                beam2_correspondence[j] = i
                
    for beam_id in beam2_correspondence:
        if ((beam2_correspondence.count(beam_id) != 1) and (beam_id is not None)):
            raise RuntimeError("Multiple beams sharing the same index encountered!")
    
    corr_beams1 = []
    corr_beams2 = []
    # any beams without correspondence?
    for i, beam1 in enumerate(beams1):
        if beam1_has_correspondece[i]:
            corr_beams1.append(beam1)
            corr_beams2.append(beams2[beam2_correspondence.index(i)])
        else:
            err_msg += f"Beam {beam1.label} from file 1 has no correspondence\n"
    for j, beam2 in enumerate(beams2):
        if beam2_correspondence[j] is None:
            err_msg += f"Beam {beam2.label} from file 2 has no correspondence\n"
    
    if err_msg:
        print(err_msg)
        
    # Done with checking beam indices
    n_beams = len(corr_beams1)
    
    # Now get beams into arrays
    beams1_en, beam1_id_start, beam1_n_E_beams, beam1_arr = beamlist_to_array(corr_beams1)
    beams2_en, beam2_id_start, beam2_n_E_beams, beam2_arr = beamlist_to_array(corr_beams2)

    # extend range by V0r_shift_rang to accomodate maximum possible shift
    minen = min(np.min(beams1_en), np.min(beams2_en)) + V0r_shift_range[0] 
    maxen = max(np.max(beams1_en), np.min(beams2_en)) + V0r_shift_range[1]
    
    averaging_scheme = np.int32(np.arange(n_beams) + 1)
    
    grid = np.arange(minen, maxen + intpol_step, intpol_step)
    
    skip_stages = np.int32([0, 0, 0, 0, 0])
    averaging_scheme = np.int32(np.arange(n_beams) + 1)
    
    # interpolate and prepare beam arrays
    (beams1_e_start_beams_out, beams1_n_e_beams_out, beams1_intpol_intensity, beams1_yfunc, ierr) = rf.prepare_beams(
            beams1_en, beam1_arr, beam1_id_start + 1, beam1_n_E_beams,
            skip_stages,
            n_beams,
            averaging_scheme,
            which_r,
            intpol_deg,
            grid,
            V0i)
    
    _check_ierr(ierr)
        
    (beams2_e_start_beams_out, beams2_n_e_beams_out, beams2_intpol_intensity, beams2_yfunc, ierr) = rf.prepare_beams(
            beams2_en, beam2_arr, beam2_id_start + 1, beam2_n_E_beams,
            skip_stages,
            n_beams,
            averaging_scheme,
            which_r,
            intpol_deg,
            grid,
            V0i)
    
    _check_ierr(ierr)
        
    
    # Ready to calculate R-factor
    V0r_shift_range_int = np.int32([int(V0r_shift_range[0]/intpol_step), int(V0r_shift_range[1]/intpol_step)])
    V0r_center = int((V0r_shift_range_int[0]+V0r_shift_range_int[1])/2)
    start_guess = np.int32([V0r_shift_range_int[0], V0r_center, V0r_shift_range_int[1]])
    
    # Same settings as used in R-factor for ViPErLEED
    fast_search = False #TODO change to True as default if we are sure it is better
    tol_r = 1 - 5e-2,
    tol_r_2 = 1 - 5e-2,
    max_fit_range = 6
    
    (best_v0r_step, best_v0r, best_R, n_v0r_evaluated, R_beams, numerators, denominators, n_overlapp_beams, ierr) = rf.r_beamset_v0r_opt_on_grid(
            which_r,
            V0r_shift_range_int,
            start_guess,
            fast_search,
            intpol_step,
            beams1_yfunc,
            beams2_yfunc,
            beams1_e_start_beams_out,
            beams2_e_start_beams_out,
            beams1_n_e_beams_out,
            beams2_n_e_beams_out,
            tol_r = tol_r,
            tol_r_2 = tol_r_2,
            max_fit_range = max_fit_range,
        )
    # If encountered an error
    _check_ierr(ierr)
    
    return best_R


def _comp_beam_index(id1, id2, eps=1e-5):
    # Compares diffraction beam indices and checks if they refer to the same beam
    check = np.abs(float(id1[0] - id2[0])) + np.abs(float(id1[1] - id2[1])) < eps
    return check

def _check_ierr(ierr):
    if ierr != 0:
        raise RuntimeError(f"ViPErLEED Fortran error code {ierr}: {error_codes[ierr]}")
    
def rot_mat_x(theta):
    rot_mat = [[1, 0, 0],
               [0,  np.cos(theta), -np.sin(theta)],
               [0, np.sin(theta), np.cos(theta)]]
    rot_mat = np.array(rot_mat)
    return rot_mat

    
def rot_mat_z(theta):
    rot_mat = [[ np.cos(theta), -np.sin(theta), 0],
               [np.sin(theta), np.cos(theta), 0],
               [0, 0, 1]]
    rot_mat = np.array(rot_mat)
    return rot_mat


switch_b_c_mat = np.array([[1,0,0],[0,0,1],[0,1,0]])