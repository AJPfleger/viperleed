"""
=======================================
   ViPErLEED Graphical User Interface
=======================================
 *** module guilib.leedsim.classes ***

Created: 2010-01-12
Author: Michele Riva

Contains Qt-independent classes used by widgets to display the real space
lattices and the LEED pattern
"""

# from fractions import Fraction
from quicktions import Fraction
from collections import Sequence
import re
import itertools
import copy
from warnings import warn as warning   # eventually will replace with logging

import numpy as np
from scipy import spatial as sp
from matplotlib import cm  # color maps
from matplotlib import colors as mpl_colors

from viperleed import guilib as gl


degrees = '\u00b0'


class RealSpace():
    def __init__(self, params):
        params = gl.LEEDParameters(params)

        self.superlattice = params['SUPERLATTICE']

        # Set up the lattices
        surf_basis = params['surfBasis']

        # self.fov is the real space field of view.
        # contains at least 4 unit cells
        self.fov = 4.2*max(surf_basis.ravel())
        self.surf = gl.Lattice(surf_basis,
                               space='real',
                               group=params['surfGroup'],
                               limit=self.fov)
        self.bulk = gl.Lattice(self.bulk_basis,
                               space='real',
                               group=params['bulkGroup'],
                               limit=self.fov)
        self.bulk.group.screws_glides = (params['bulk3Dsym'],
                                         self.bulk.cell_shape)

    @property
    def bulk_basis(self):
        """
        Basis of the bulk lattice
        """
        if hasattr(self, 'bulk'):
            return self.bulk.basis
        return np.dot(np.linalg.inv(self.superlattice),
                      self.surf.basis).round(10)

    def angle_for_horizontal_bulk(self, direction):
        if direction not in (0, 1):
            raise ValueError("First positional argument of "
                             "angle_for_horizontal_bulk() "
                             f"should be 0 or 1. Got {direction!r} instead.")

        basis = self.bulk.basis[direction]
        # NB: np.arctan2 takes first the 'y' then the 'x'!
        theta = np.arctan2(basis[1], basis[0])

        return np.degrees(theta)


class LEEDPattern():
    # @gl.profile_calls(print_args=[30])
    def __init__(self, leed_parameters):
        # run leed_parameters through gl.LEEDParameters, so that all
        # parameters are correctly interpreted, and missing optional values
        # are set to their default
        self.__parameters = gl.LEEDParameters(leed_parameters)

        # The following attributes are set by __build_lattices() and
        # __build_LEEDPattern()
        # * reciprocal-space lattices for surface and bulk
        self.reciprocal_lattices = {'surf': None, 'bulk': None}

        # * characteristics of domains generated by symmetry operations
        #   of the bulk. 'g' is a list (one element per domain) containing
        #   all the reciprocal-space wave-vectors (in x,y Cartesian coordinates)
        #   of the beams from one domain
        self.domains = {'operations': None, 'g': None}

        ## NEED TO REDUCE THE NUMBER OF ATTRIBUTES FROM HERE ON
        self.surfLEED = None  # like self.domains['g'], but flattened
        self.superposedBeams = None  # grouping of beam indices telling which ones overlap   ## PROBABLY WILL GO with BeamIndexList
        self.names = None     # strings of beam names (wrt bulk basis)            ## REPLACE via BeamIndexList!

        # The following one is related to symmetry-equivalent beams
        self.firstDomRefs = None  # references of equivalent beams in 1st domain  ## REPLACE (different logics for off normal).
        
        # The following ones are related to the LEED subpatterns                  ## THE LOGICS NEEDS TO CHANGE!
        # Will probably have a self.patterns dictionary that is initially populated only with some of the subpatterns. Other combinations will be dynamically generated and stored as new keys, with some reasonable hashing.
        self.firstLEED = None  # subpattern of first domain
        self.domsLEED = None   # subpatterns for all domains
        self.domColors = None  # colors for plotting multiple domains

        self.__build_lattices()
        self.__build_LEEDPattern()

    @property
    def bulk_basis(self):
        if self.reciprocal_lattices['bulk'] is None:
            return np.dot(self.superlattices[0].T,                              # ENOUGH TO HAVE THE FIRST ONE
                          self.reciprocal_lattices['surf'].basis)
        return self.reciprocal_lattices['bulk'].basis

    @property
    def max_energy(self):
        """
        Maximum LEED energy
        """
        return self.__parameters['eMax']

    @property
    def n_beams(self):                                                          # NOT CORRECT FOR MULTIPLE STRUCTURES. Probably not needed
        """
        Number of LEED beams in the pattern
        """
        return self.reciprocal_lattices['surf'].n_beams

    @property
    def n_domains(self):
        """
        Number of distinct domains produced by the symmetry operations of the
        bulk
        """
        return len(self.domains['operations'])

    @property
    def superlattices(self):
        """
        Numpy ndarray of superlattice matrices generating the symmetry-related
        domains. The first element is the one generating the lattice whose basis
        is given in the constructor as a LEED parameter
        """
        superlattice = self.__parameters['SUPERLATTICE']
        operations = self.domains['operations']
        if operations is None:
            operations = [gl.PlaneGroup.E]  # identity matrix
        # return np.asarray([np.dot(superlattice, operation)
                           # for operation in operations])
        return np.einsum('ij,mjk->mik', superlattice, operations)
    
    @property
    def primary_beam_theta(self):
        """
        Polar angle of incidence with respect to the direction perpendicular
        to the surface
        """
        return self.__parameters['beamIncidence'][0]
    
    @property
    def primary_beam_phi(self):
        """
        Azimuthal angle of incidence of the primary beam with respect to the
        x axis. Positive counterclockwise when looking down on the surface.
        """
        return self.__parameters['beamIncidence'][1]
    
    @property
    def primary_beam_direction(self):                                           # will probably not even use this
        """
        2-tuple representing the in-plane direction vector of incidence,
        in Cartesian coordinates
        """
        if self.primary_beam_theta == 0:
            return (0, 0)
        phi = np.radians(self.primary_beam_phi)
        return np.cos(phi), np.sin(phi)

    def __build_lattices(self):                                                 # Not even sure if we really need both lattices anymore. Probably bulk + domains are enough
        # Create dummy surface lattice just to get the reciprocal basis
        surf = gl.Lattice(self.__parameters['surfBasis'])

        # and get the maximum screen radius
        max_radius = self.screen_radius(self.max_energy)

        # Now make the reciprocal lattices:
        self.reciprocal_lattices['surf'] = gl.Lattice(
            surf.reciprocal_basis, space='reciprocal',
            group=self.__parameters['surfGroup'], limit=max_radius
            )
        self.reciprocal_lattices['bulk'] = gl.Lattice(
            self.bulk_basis, space='reciprocal',
            group=self.__parameters['bulkGroup'], limit=max_radius
            )
        self.reciprocal_lattices['bulk'].group.screws_glides = (
            self.__parameters['bulk3Dsym'],
            self.reciprocal_lattices['bulk'].cell_shape
            )

    # @gl.profile_lines
    def __build_LEEDPattern(self):                                                ## bottleneck!

        # 1) get the (bulk) operations that generate symmetry-equivalent domains
        self.domains['operations'] = self.__find_domain_operations()

        # 2) generate the gx gy coordinates for all the domains                   ## PERHAPS IT MAKES SENSE TO GENERATE hk(s) FIRST? THESE CAN BE CONVERTED TO a BeamIndexList
        self.domains['g'] = [                                                     ## NEEDS TO CHANGE TO ACCOUNT FOR OFF-NORMAL. It may also be that I don't need this at all,
            np.linalg.multi_dot(
                (self.reciprocal_lattices['surf'].hk,
                 np.linalg.inv(superlattice).T,
                 self.bulk_basis)
                )
            for superlattice in self.superlattices                                ## CAN BE PART OF LEEDDomains
            ]

        # 3) prepare the full LEED pattern of the surface, including all
        # domains
        surfLEEDx = np.array([self.domains['g'][i][:, 0]
                              for i in range(self.n_domains)]).flatten()
        surfLEEDy = np.array([self.domains['g'][i][:, 1]
                              for i in range(self.n_domains)]).flatten()
        self.surfLEED = np.array(list(zip(surfLEEDx, surfLEEDy)))

        # 4) find superposed beams
        self.superposedBeams = self.get_supSpots()

        # 5) prepare the formatted names of the fractional indices
        self.names = np.array([
            self.formatFractionalIndices(self.reciprocal_lattices['surf'].hk, m)  # MAIN BOTTLENECK: > half time of whole method
            for m in self.superlattices])                                         # WILL NOT EXIST

        # 6) and build the subpatterns
        self.__build_subpatterns()                                                ## BOTTLENECK: half of time of whole method

    def get_supSpots(self):                                                       ## TO EVALUATE WHETHER IT'S FASTER TO USE BeamIndexList
        # Group all the beams into separate groups, such that each group
        # contains the indices of overlapping beams (can be one index if non
        # overlapping)
        tree = sp.cKDTree(self.surfLEED)
        return np.array(tree.query_ball_point(x=self.surfLEED, r=1e-8))

    # @gl.profile_calls(print_args=[30])
    def get_beamGrouping(self, domains=None):                                     ## TO RETHINK FOR NON-NORMAL INCIDENCE  ## BOTTLENECK for __build_subpatterns
        # this is wrong for non-normal incidence!
        # all domains should be treated separately, rather than using the
        # symmetry of the first one, since the special direction given by the
        # beam incidence has a different effect on each domain
        self.firstDomRefs = self.get_FirstDomainSymmetry()                        ## BOTTLENECK?

        if domains is None:
            domains = range(self.n_domains)

        # beamsRefs contains at index [i, j] a list of the indices of beams of
        # domain domains[i] equivalent to beam j (including j)
        beamsRefs = []
        for dom in domains: 
            beamsRefs.append([crossRef + dom*self.n_beams
                              for crossRef in self.firstDomRefs])
        return np.array(beamsRefs, dtype=object)

    def get_equivalentSpots(self, domains=None):                                  ## REPLACE with generic function!
        if not hasattr(domains, '__len__') and domains is not None:
            raise TypeError("Invalid type for domains. "
                            "Should be None or an array-like.")
        if domains is None:
            # output spots from all domains
            domains = range(self.n_domains)
        elif not all(isinstance(dom, int) for dom in domains):
            raise ValueError("Invalid domain index. "
                             "All indices should be integers")
        elif any(dom < 0 or dom >= self.n_domains for dom in domains):
            raise ValueError("Domain index out of range. "
                             "Indices should be between 0 "
                             f"and {self.n_domains}.")

        names = self.names[domains]
        beamRefs = self.get_beamGrouping(domains)

        # get ready to prepare one dictionary per each domain:
        # key: beam name
        # value: names of beams equivalent to key
        #        Notice that for each key (=beam) in one domain, one should
        #        also include as equivalent beams those from other domains
        #        at the same positional index.
        #        !!!THIS IS A PROBLEM FOR NON-NORMAL INCIDENCE!!!
        #        --> get this list (the same for all domains) ready first
        allRefs = [np.concatenate(beamRefs[:, beam]).astype(int)
                   for beam in range(self.n_beams)]
        refNames = [set(self.names.ravel()[beamRef]) for beamRef in allRefs]

        # now pack the dictionaries
        # Notice that it is necessary to have one dictionary per domain since
        #   some domains will give rise to a subset of all the LEED spots:
        #   e.g., in a (2x1) on square bulk, one domain will give spot (1/2, 0)
        #   the other domain spot (0, 1/2)
        # Having all the dictionaries allows to determine which of the
        #   superposed spots are indeed equivalent (see next comment) as well
        #   as which domains overlap
        domsDicts = [dict(zip(domNames, refNames)) for domNames in names]

        # now figure out which of the beams are symmetry equivalent
        # taking superposition of spots into account:
        # spots originating from beams that are symmetry equivalent within
        # each domain, are symmetry equivalent only if all domains contribute
        # with symmetry-equivalent beams in all spots.
        #
        # For example (hexagonal bulk):
        # dom1: (1 0), (-1 0), (1 -1), (-1 1) equivalent
        # dom2: (1 0), (-1 0), (0 -1), (0 1)  equivalent
        # dom3: (1 0), (-1 0)                 equivalent
        # --> (1 0) and (-1 0) are equivalent
        #
        # dom1: (1 0),  (-1 0),  (1 -1), (-1 1)    equivalent
        # dom2:                  (1 -1), (-1 1)    equivalent
        # dom3: (0, 1), (0, -1), (1 -1), (-1 1)    equivalent
        # --> (1 -1) and (-1 1) are equivalent, but are
        #     not equivalent to [(1 0), (-1 0)]
        eqBeams = []
        for name in names.ravel():
            setLst = [dDict[name] for dDict in domsDicts if name in dDict]
            if setLst:
                newBeams = set.intersection(*setLst)
                # remove the keys of the beams that have
                # already been processed from each domain
                for domDict in domsDicts:
                    for beam in newBeams:
                        if beam in domDict:
                            del domDict[beam]
                eqBeams.append(newBeams)

        # sort within each equivalence group
        lstBeams = [sorted(list(beams), key=self.beamsSortCriterion)
                    for beams in eqBeams]
        # and by energy
        sortedBeams = sorted(lstBeams, key=self.sortEnergy)

        beamsWithIndices = []
        overlapDoms = []
        for (i, beams) in enumerate(sortedBeams):
            for beam in beams:
                overlapDoms = [dom + 1 for dom in domains
                               if beam in self.names[dom].ravel()]
                beamsWithIndices.append([beam, i, overlapDoms])

        # Now find which of the beams are extinct due to glide, place them
        # in a list of beam indices in the same order as in self.names[i]
        extinct = self.get_ExtinctFirstDomain()

        extinctNames = self.names[:, extinct]
        # notice that extinctNames is an empty list if there are no glide
        # extinct beams.
        for b, (beam, group, doms) in enumerate(beamsWithIndices):
            extDoms = [dom for dom in doms if beam in extinctNames[dom-1]]
            # Notice the dom-1 because of the way the doms list is
            # built in the previous for loop

            beamsWithIndices[b] = [beam, group, doms, extDoms]
            # now, only in case extDoms is of length 1, i.e., one domain
            # only gives rise to the extinct beam, the group index goes
            # negative
            # !!! Perhaps will be changed with the better version in base.py !!!
            if len(extDoms) == 1:
                beamsWithIndices[b][1] *= -1

        return beamsWithIndices

    def beamsSortCriterion(self, beamstr):                                        ## this may go into BeamIndexList
        beam = eval(beamstr)  # returns a tuple                                   ## This will go

        sortH = beam[0]
        sortK = beam[1]

        return (-sortH-sortK, -sortH)
    
    def sortEnergy(self, beamlist):                                               ## this may go into BeamIndexList
        beam = eval(beamlist[0])  # returns a tuple
        # sort by Energy, i.e., by g^2:
        return np.linalg.norm(np.dot(beam, self.bulk_basis))

    # @gl.profile_lines
    def __build_subpatterns(self):
        # Now sort the sub-patterns:
        # - There will always be a firstLEED and a domsLEED
        #   This is to handle the plotting of the first domain only.              ## NEEDS TO CHANGE TO DISPLAY EACH DOMAIN SEPARATELY OR AN ARBITRARY COMBINATION OF DOMAINS
        #   All entries in these lists are of type LEEDsubpattern
        #
        # - firstLEED, contains at most two entries: the first one
        #   includes all non-extinct beams, the second one
        #   the extinct ones, if any are present
        # - domsLEED is empty if only one domain is present.
        #   Otherwise, it contains:
        #   * one entry with superimposed spots
        #   * at most two entries for each domain.
        #     first entry: non-extinct; second entry: extinct (if any)

        doms = self.domains['g']
        symEq = self.get_beamGrouping()                                          # BOTTLENECK
        names = self.names

        maskFirst = np.full(self.n_beams, True)
        maskFirst[self.get_ExtinctFirstDomain()] = False

        self.firstLEED = [LEEDsubpattern(doms[0][maskFirst],
                                         symEq[0][maskFirst],
                                         names[0][maskFirst])]
        if all(maskFirst):  # no glide-extinct beams
            pass
        else:
            glideAlpha = 0.2
            glideScale = 2
            maskExtinct = np.invert(maskFirst)
            self.firstLEED.append(LEEDsubpattern(doms[0][maskExtinct],
                                                 symEq[0][maskExtinct],
                                                 names[0][maskExtinct],
                                                 color='k',
                                                 alpha=glideAlpha,
                                                 marker='x',
                                                 sizeScale=glideScale
                                                 ))

        self.domsLEED = []
        self.domColors = None
        if self.n_domains > 1:
            # If there are domains, there always will be overlapping spots,
            # at least those at integer orders

            # superposedMask is True at all the beam indices of beams that
            # are superposed to others
            superposedMask = np.array([len(sup) > 1
                                       for sup in self.superposedBeams])

            # figure out which domains superpose:
            overlapDoms = [[x//self.n_beams + 1 for x in sup]
                           for sup in self.superposedBeams[superposedMask]]
            self.domsLEED = [LEEDsubpattern(self.surfLEED[superposedMask],
                                            symEq.ravel()[superposedMask],
                                            names.ravel()[superposedMask],
                                            domain=-1,
                                            color='gray',
                                            overlapDoms=overlapDoms
                                            )]

            # define colors
            self.domColors = cm.gnuplot(np.linspace(0.1, 0.9, self.n_domains))

            for dom in range(self.n_domains):
                mask = np.invert(
                    superposedMask[dom*self.n_beams:(dom+1)*self.n_beams])
                maskDom = np.logical_and(maskFirst, mask)
                self.domsLEED.append(LEEDsubpattern(doms[dom][maskDom],
                                                    symEq[dom][maskDom],
                                                    names[dom][maskDom],
                                                    domain=dom+1,
                                                    color=self.domColors[dom]
                                                    )
                                     )
                if all(maskFirst):  # no glide extinct
                    pass
                else:
                    maskDomExtinct = np.logical_and(maskExtinct, mask)
                    self.domsLEED.append(
                        LEEDsubpattern(doms[dom][maskDomExtinct],
                                       symEq[dom][maskDomExtinct],
                                       names[dom][maskDomExtinct],
                                       domain=dom+1,
                                       color=self.domColors[dom],
                                       alpha=glideAlpha,
                                       marker='x',
                                       sizeScale=glideScale))

    def screen_radius(self, en):
        return gl.screen_radius(en, self.__parameters['screenAperture'])

    def get_FirstDomainSymmetry(self):
        """
        Returns
        -------
        crossRefs: list of np.arrays,
                   length == len(self.reciprocal_lattices['surf'].hk)
                   Each np.array contains the positional indices of the
                   beams equivalent to the current one (including
                   self-reference)
        """

        hk = self.reciprocal_lattices['surf'].hk
        N = len(hk)
        symOps = self.reciprocal_lattices['surf'].group.group_ops()

        # at first, use sets to avoid duplicates
        crossRefs = [{i} for i in range(N)]

        for op in symOps:
            hk_transformed = np.dot(op, hk.T).T.tolist()
            # transform hk according to the operation of the group
            for i in range(N):
                idx = hk_transformed.index(hk[i].tolist())
                # find which transformed hk is equal to the current beam
                # NB: there's always only one for each (beam, operation) pair
                #
                # and add it to the set of cross references for the current
                # beam
                crossRefs[i] |= {idx}

        # then convert each set to a np.array of int, so that it's iterable
        # and it's easy to process later
        return np.array([np.array(list(x), dtype=int) for x in crossRefs], 
                        dtype=object)

    def get_ExtinctFirstDomain(self):
        """
        Returns
        -------
        list of indices of beams of the first domain that are extinct
        due to glide
        """
        hk = self.reciprocal_lattices['surf'].hk
        group = self.reciprocal_lattices['surf'].group.group

        if 'g' in group:  # group has glide
            if '[1 0]' in group:  # pg or pmg
                idx = np.where([x[1] == 0 and abs(x[0] % 2) == 1
                                for x in hk])[0].tolist()
            elif '[0 1]' in group:  # pg or pmg
                idx = np.where([x[0] == 0 and abs(x[1] % 2) == 1
                                for x in hk])[0].tolist()
            else:  # pgg or p4g
                idx = np.where([(x[1] == 0 and abs(x[0] % 2) == 1)
                                or (x[0] == 0 and abs(x[1] % 2) == 1)
                                for x in hk])[0].tolist()
        else:
            idx = []

        return idx

    def __find_domain_operations(self):
        """
        Finds the symmetry operations of the bulk lattice that give distinct
        domains in LEED.
        NB: this function gives different results than what one would get from
        LEEDPat, as we're interested also in the symmetry relations between the
        intensities of the spots, while LEEDPat cares only about the presence
        or not of any spot.

        Returns
        -------
        list of operations

        -------
        """
        # The current version is based on the concept of co-sets of a group.
        # Given a group G and a subgroup H, the left co-set of H with respect
        # to the group operation g of G is
        #           gH = {g*h : h in H}.
        # Additionally, we take into account that each element of G is found in
        # exactly only one co-set (e.g., H is the identity co-set).
        #
        # The operations g_i that generate distinct co-sets are those that will
        # generate distinct lattices

        def __array_2_tuple(arr):
            """
            Convenience function that is used to convert a 2x2 array to a 2x2
            tuple
            """
            return tuple(map(tuple, arr))

        # 1) project the operations from the surface group to the bulk; also
        #    rounding to integers
        transform = np.linalg.inv(self.superlattices[0])                        # FIRST ONE IS ENOUGH
        surf_ops = tuple(
            op.round().astype(int)
            for op
            in self.reciprocal_lattices['surf'].group.transform(transform)
            )

        # 2) keep track of the operations of the bulk group that are already in
        #    a co-set, and of the group operations giving distinct co-sets
        coset_ops = set()
        _ops = []

        # 3) run through the bulk operations, adding the operations of new
        #    co-sets to the set above
        bulk_group = self.reciprocal_lattices['bulk'].group
        bulk_ops = bulk_group.group_ops(include_3d=True)

        for b_op in bulk_ops:
            if b_op in coset_ops:
                continue
            _ops.append(b_op)
            coset = set(__array_2_tuple(np.dot(b_op, surf_op))
                        for surf_op in surf_ops)
            coset_ops.update(coset)

        return _ops

    def formatFractionalIndices(self, hk, m):                                     ## this will probably go, and will rather use BeamIndex; BOTTLENECK
        """
        Method that generates fractional indices of a superstructure m whose
        integer indices are hk.

        Parameters
        ----------
        hk, 2D-array
            Integer indices along the two directions to be formatted

        m, 2x2 np.array
            superlattice matrix

        Returns
        -------
        names, 1D array
            each element is a string with formatted names for the indices
        """

        # The beam indices [hb,kb] for the surface indices [h,k] are
        #    [hb, kb] = np.dot([h, k], G),
        # with G = np.linalg.inv(M).transpose()
        hkbulk = np.dot(np.linalg.inv(m), hk.T).T

        # now get the formatting done:
        # all fractional indices are of type nn/mu with nn integer, and
        mu = abs(np.round(np.linalg.det(m)).astype(int)).item()

        # notice that, to prevent Fraction().limit_denominator() from
        # overflowing I'm casting the numpy-type numbers to their native
        # python type via .item()
        names = [', '.join([str(Fraction(hh.item()).limit_denominator(mu))         ## BOTTLENECK is limit_denominator
                            for hh in hkb]) for hkb in hkbulk]

        return np.array(names)

    def rotate(self, angle, which='surf'):
        """
        This function is a mess and needs to be split into two functions.
        It currently does two different things: if which='bulk', it returns a
        copy of the bulk lattice. If which='surf' it rotates all the LEED
        subpatterns. It would probably be nicer to also have the bulk pattern
        be a special subpattern.
        """
        which = which[0:4]
        if which not in ['surf', 'bulk']:
            raise ValueError("LEEDPattern: Only 'surf', 'surface', or "
                             "'bulk' are acceptable values for rotate()")
        if hasattr(angle, '__len__'):
            raise ValueError('Angle input is not a scalar')

        if which == 'surf':
            angle = np.radians(angle)
            rot = np.array([[np.cos(angle), np.sin(angle)],
                            [-np.sin(angle), np.cos(angle)]])
            for pat in [*self.firstLEED, *self.domsLEED]:
                pat.transformCoords(rot)
            return None
        return self.reciprocal_lattices['bulk'].get_rotated_lattice(angle)


class LEEDSymmetryDomains(Sequence):                                            # will also need a LEEDStructuralDomains for handling multiple superlattices
    """
    Collection of LEED domains generated from one superlattice matrix
    and the symmetry operations of a bulk group. LEEDSymmetryDomains is an
    immutable sequence (i.e., tuple-like). Calling LEEDSymmetryDomains[i]
    returns a viperleed.Lattice of the domain
    """
    # @gl.exec_time
    def __init__(self, leed_parameters):
        self.__parameters = gl.LEEDParameters(leed_parameters)
        super().__init__()
        
        # self.__operations is a list of the bulk symmetry operations generating
        # distinct domains. Read by self.operations.
        self.__operations = self.__find_domain_operations()
        
        # self.__superlattices is a numpy.ndarray of the superlattice matrices
        # that generate distinct domains. It can be accessed via the attribute
        # self.superlattices, and it is permanently set there the first time the
        # attribute is accessed
        self.__superlattices = None

        # self.__domains is the underlying list that is accessed when issuing
        # self[index]. It's a list of gl.Lattice instances
        self.__domains = self.__build_domains()

        # self.__equiv_spots_no_superpos is a list of dictionaries of
        # dictionaries, one element per domain, ordered as in self.__domains
        # (i.e., in self).
        # The outer dictionary is labeled by 'norm', 'other', or an azimuthal
        # angle. For each of the angle settings, the inner dictionary is in the
        # form {beam_i: set(beams_i)} with beams of domain i and their
        # equivalents within the domain at the specified primary beam angle(s).
        # Used only internally, cannot be accessed
        self.__equiv_spots_no_superpos = self.__get_spot_equivalence()

        # self.__extinct_spots list of dictionaries, one element per domain,
        # same order as in self.__domains (i.e., in self). Each dictionary has
        # keys 'norm', 'other', or an azimuthal angle, and as values a numpy
        # array that lists the extinct beams of the domain at the specified
        # beam angle(s).
        # Used only internally, cannot be accessed
        self.__extinct_spots = self.__get_extinct()

        # self.__equiv_spots_no_superpos and self.__extinct_spots are used in
        # the public method self.equivalent_spots(domains, theta, phi) for
        # creating the appropriate LEEDEquivalentBeams instance (unless it's
        # already cached), whose reference is stored into self.__last_eq
        self.__last_eq = None

        # The return value of self.equivalent_spots has beams expressed as
        # tuples, but including ONLY THE NUMERATOR of the beam indices with
        # respect to the bulk. Use self.denominator_for_bulk_beams to retrieve
        # the correct denominator as an integer, which accesses the private
        # property self.__denominator
        self.__denominator = None
    
    def __repr__(self):
        txt = (f"{self.cell_shape} "
               + f"viperleed.LEEDSymmetryDomains({self.__parameters})")
        return txt
    
    def __len__(self):
        return len(self.__domains)
    
    def __getitem__(self, el):
        # NB: if a slice is given, the result is NOT type-preserving, i.e.,
        # it will not be a LEEDSymmetryDomains but a list of Lattice(s)
        return self.__domains[el]

    @property
    def groups(self):
        return {'surf': self.__parameters['surfGroup'],
                'bulk': self.__parameters['bulkGroup']}

    @property
    def bulk_basis(self):
        """
        Returns the reciprocal-space basis of the bulk lattice
        """
        return np.dot(self.superlattices[0].T, self[0].basis).round(10)

    @property
    def n_domains(self):
        """
        Number of distinct domains produced by the symmetry operations of the
        bulk
        """
        return len(self)

    @property
    def operations(self):
        return self.__operations

    @property
    def superlattices(self):
        """
        Numpy ndarray of superlattice matrices generating the symmetry-related
        domains. The first element is the one generating the lattice whose basis
        is given in the constructor as a LEED parameter
        """
        if self.__superlattices is None:
            superlattice = self.__parameters['SUPERLATTICE']
            self.__superlattices = np.einsum('ij,mjk->mik',
                                             superlattice,
                                             self.operations)
        return self.__superlattices

    @property
    def g_vectors(self):
        """
        g_vectors[i] is a list of the lattice vectors of domain i in the same
        coordinate system as the bulk basis
        """
        return [dom.lattice for dom in self]

    @property
    def denominator_for_bulk_beams(self):
        if self.__denominator is None:
            self.__denominator = int(
                abs(round(np.linalg.det(self.superlattices[0])))
            )
        return self.__denominator

    def angular_offsets(self, zero_pi=False):
        """
        Returns a list of the angles between the first lattice vectors of all
        domains and those of the first domain
        """
        first_dom_angle = gl.orientation(self[0].real_basis[0], zero_pi)
        return [gl.orientation(dom.real_basis[0], zero_pi) - first_dom_angle
                for dom in self]

    # @gl.profile_lines
    def beams_equivalent_to(self, beam, **kwargs):    # this will probably move to LEEDPattern later on? As is, it's fast enough not to bother
        """
        Given a beam, returns beams that are equivalent to it. This function
        cannot be used before issuing once self.equivalent_spots at the same
        angular conditions and with the same domains.
        
        Parameters
        ----------
        beam : 2-element array-like of numbers
            Some reference to the beam. Which reference is passed should be
            explicitly specified with the in_format parameter
        in_format : str, keyword only
            Acceptable values are:
                - 'fractional':
                    when passing the full bulk fractional indices. In this case,
                    beam can be a list-like with two int, or two floats, or a
                    string in the form 'num1/den1, num2/den2' ('/den_i' can be
                    skipped if == 1)
                - 'numerator':
                    when passing only the numerator of the bulk fractional index
                    In this case, beam should be a tuple of integers. The
                    denominator is taken automatically from the superlattice
                    matrix
                - 'g':
                    when passing the vector position in Cartesian coordinates.
                    In this case, beam should be expressed in a reference system
                    with z orthogonal to the surface (DO WE NEED THIS? PROBABLY
                    NOT AFTER I FIGURE OUT THE GENERAL POSITIONS ON THE SCREEN),
                    and in the same in-plane reference as the bulk basis
        - out_format='' : str, optional (default out_format=in_format)
            Same values as in_format. 'numerator' probably doesn't make much
            sense.

        Returns
        -------
        list
            as many elements as there are beams equivalent to beam, each one is
            a (beam, index, text) tuple, with
            beam : tuple
                formatted as requested in out_format
            index : gl.BeamIndex
                fractional indices
            text : str
                form "i+(j)+..." where i,j,... are the indices of the domains
                that contribute to the beam, and parenthesized ones are extinct
                contributions
        """
        # Potentially useful for the hovering annotations.
        # They need the following info:
        # - beams equivalent to beam
        # - for all beams:
        #   * some type of coordinate, probably best to give out the g vectors?
        #     it will need to be processed later on to get the right rotation
        #     (depending on the view angle), and, consequently the pixel
        #     coordinates in the canvas
        #   * the fractional index + a list of the domains that contribute to
        #     that beam, perhaps already formatted as a string?
        if self.__last_eq is None:
            raise RuntimeError("beams_equivalent_to cannot be used before "
                               "running once self.equivalent_spots at the same "
                               "angular conditions and with the same domains")
        in_format = kwargs.get('in_format', '')
        if in_format not in ('fractional', 'numerator', 'g'):
            raise ValueError("beams_equivalent_to: in_format is mandatory, and "
                             "should be either 'fractional', 'numerator', or "
                             "'g'")
        elif in_format == 'g':
            # Since g_bulk = (h,k)_bulk @ basis_bulk, with basis_bulk the
            # reciprocal-lattice bulk basis, then
            # (h,k)_bulk = g_bulk @ basis_bulk^(-1)
            # The indices are the fractional ones in this case.
            beam_indices = np.dot(beam, np.linalg.inv(self.bulk_basis))
        else:
            beam_indices = beam

        # Now process the beam indices to have only the numerator, as this is
        # what is used in the dictionaries
        if in_format in ('fractional', 'g'):
            beam_indices = [b*self.denominator_for_bulk_beams
                            for b in beam_indices]
            # check that the indices are consistent with the bulk basis
            if any(abs(round(b) - b) > 1e-4 for b in beam_indices):
                raise ValueError("beams_equivalent_to: beam indices are "
                                 "incompatible with the bulk basis")
            beam_indices = [int(round(b)) for b in beam_indices]

        # make the indices a tuple for lookup in the dictionary
        beam_indices = tuple(beam_indices)
        try: 
            eq_beams = self.__last_eq.equivalent_beams_dict[beam_indices]
        except KeyError:
            raise ValueError(f"beams_equivalent_to: beam {beam} (transformed to"
                             f" {beam_indices}) not found. "
                             "It may not be an acceptable index for the "
                             "system, or may lie outside the energy range")

        # Transform eq_beams into a list, as it's a set in the dictionary, but
        # we need to keep the order for the output
        eq_beams = list(eq_beams)

        # Now get the names of the domains that overlap at each of the beams,
        # also accounting for whether the domain contributes with an extinct
        # spot
        beams, _, domains, extinct_domains = zip(*self.__last_eq.indexed_beams)
        overlapping = []
        for b in eq_beams:
            idx = beams.index(b)
            overlap = [f"({d})" if d in extinct_domains[idx] else f"{d}"
                       for d in domains[idx]]
            overlapping.append("+".join(overlap))

        # Finally process the beam indices according to the format requested
        fractional = [gl.BeamIndex(b,
                                   denominator=self.denominator_for_bulk_beams,
                                   from_numerators=True)
                      for b in eq_beams]

        out_format = kwargs.get('out_format', in_format)
        if out_format == 'fractional':
            out_beams = fractional
        elif out_format == 'numerator':
            out_beams = [b.numerators for b in fractional]
        elif out_format == 'g':
            out_beams = np.dot(fractional, self.bulk_basis)
            # This makes each element be an array with dtype=object, each entry
            # being a 2-tuple of Fractions. Not sure if it's worth converting to
            # float, but it can be done straightforwardly with .astype(float)
        else:
            raise ValueError("beams_equivalent_to: invalid out_format "
                             f"{out_format!r}. Expected 'fractional', "
                             "'numerator', or 'g'")
        return list(zip(out_beams, fractional, overlapping))

    # @gl.profile_lines
    def equivalent_spots(self, domains=None, theta=None, phi=None):
        """
        Returns a list of beams grouped by equivalence, given a primary beam
        direction defined by polar and azimuthal angles
        
        Parameters
        ----------
        domains : list of int, or None (default=None)
            only the beams of the domains selected by these indices will be
            output. If None, all the domains are used.
        theta, phi : number or None
            polar and azimuthal directions in degrees of the primary beam. If
            not given, those defined at instantiation are used
            theta should be within 0 and 90
            phi is positive counterclockwise, and measured from the x axis
                in the Cartesian reference of the real-space basis of the
                first domain
        """
        # type- and value-check the input, and processing when needed
        if theta is None:
            theta = self.__parameters['beamIncidence'][0]
        if phi is None:
            phi = self.__parameters['beamIncidence'][1]
        if not all(isinstance(angle, (int, float)) for angle in (theta, phi)):
            raise TypeError("LEEDSymmetryDomains: invalid angles. "
                            "Expected a real number.")
        if theta < 0 or theta > 90:                                               # Allow theta < 0 and update phi correctly in this case
            raise ValueError("LEEDSymmetryDomains: polar angle must be between "
                             f"0 and 90 degrees. Found {theta}")
        if domains is None:
            domains = range(self.n_domains)
        elif not all(isinstance(dom, int) for dom in domains):
            raise ValueError("Invalid domain index. "
                             "All indices should be integers")
        elif any(dom < 0 or dom >= self.n_domains for dom in domains):
            raise ValueError("Domain index out of range. "
                             "Indices should be between 0 "
                             f"and {self.n_domains}.")

        # select the bare dictionaries
        kwargs = {'domains': domains, 'theta': theta, 'phi': phi}
        domains_dicts = self.__beams_for_primary_angles('equivalent', **kwargs)
        extinct_beams = self.__beams_for_primary_angles('extinct', **kwargs)
        
        # Now, only if the beam is impinging normally, one has to rework a bit
        # the dictionary. In fact, at normal incidence, one should not only
        # consider the spot equivalence within each domain, but also the
        # equivalence among different domains. For example, the two (2x1)
        # domains on a p4xx square lattice produce spots (1/2 0) and (0 1/2),
        # respectively, that are equivalent to one another at normal incidence.
        # This means that, at normal incidence, for each domain i, all the
        # beams (values) associated with beam j (key) are the same, although
        # beam j is a different tuple, and comprise all the beams for all
        # domains that are equivalent to the j-th beam of each domain
        #
        # Will construct a list of sets, in the same order as the keys,
        # where each set is the union of the stars of the domains. This is
        # possible since all dictionaries were created with the same order
        # of insertion (actually, from the same dictionary)
        if abs(theta) < 1e-4:
            all_stars = [set.union(*stars)
                         for stars in zip(*(d.values() for d in domains_dicts))]
            # now place the unions in the domain dictionaries, preserving the
            # original keys
            domains_dicts = [dict(zip(d.keys(), all_stars))
                             for d in domains_dicts]

        # and defer the processing to the LEEDEquivalentBeams class, that
        # needs to know the reciprocal-space bulk basis for processing.
        # Prepare the keyword arguments before:
        kwargs = {'extinct_lists': extinct_beams, 'basis': self.bulk_basis,
                  'domain_ids': [dom + 1 for dom in domains],
                  'superlattice': self.superlattices[0],
                  'angle_key': self.__key_from_angles(theta, phi, domains)}
        self.__last_eq = LEEDEquivalentBeams(domains_dicts, **kwargs)
        return self.__last_eq.indexed_beams

    def __beams_for_primary_angles(self, which_beams, theta=None, phi=None,
                                   domains=None):
        """
        Returns the correct equivalent or extinct beams given the direction
        angles of the primary beam

        Parameters
        ----------
        which_beams : str
            Can be either 'equivalent' (or any contraction down to 'eq') or
            'extinct' (or any contraction down to 'ex'). Determines what is
            returned, the dictionary of equivalent beams or the lists of
            extinct ones, respectively
        theta, phi : number or None (default=None)
            if None, the angle given as a parameter in the constructor is used.
            The azimuthal angle phi is measured with respect to the x axis
            (positive counterclockwise), in the same Cartesian coordinate frame
            as the real-space basis of the first domain. Angles are in degrees.
        domains : list of int or None (default=None)
            select which domains should be output. If None, all domains are used

        Returns
        -------
        list of dict
            if which_beams[:2] == 'eq'
            keys : tuple
                beam j of domain i
            values : set of tuple
                the star of beam j in domain i
        list
            if which_beams[:2] == 'ex'
            
        """
        # check and fix the input if needed
        which_beams = which_beams[:2]
        if which_beams not in ('eq', 'ex'):
            raise ValueError("LEEDSymmetryDomains: invalid parameter for "
                             "selecting which beams to output. Must be 'eq'"
                             "or 'ex' for equivalent or extinct")
        if theta is None:
            theta = self.__parameters['beamIncidence'][0]
        if phi is None:
            phi = self.__parameters['beamIncidence'][1]

        if domains is None:
            domains = range(self.n_domains)

        # now select which keys need to be retrieved
        key = self.__key_from_angles(theta, phi, domains)

        # and from which dictionary
        if which_beams == 'eq':
            beams = self.__equiv_spots_no_superpos
        else:
            beams = self.__extinct_spots

        # retrieve the correct dictionary keys, falling back on 'other' if the
        # angle phi is not one of the special directions
        return [beams[dom].get(key, beams[dom]['other']) for dom in domains]

    def __key_from_angles(self, theta, phi, domains):
        """
        Given the polar and azimuthal angles of incidence of the beam,
        figure out which among the keys 'norm', 'other', or any of the mirror
        direction angles needs to be retrieved
        """
        a_angle = gl.orientation(self[0].real_basis[0], zero_pi=False)
        phi = (phi - a_angle) % 180

        if theta < 1e-4:
            key = 'norm'
        elif abs(phi - round(phi)) > 1e-4:
            # will need to use 'other' for all, as all angles in the
            # dictionaries are integers: 0, 30, 45, 60, ...
            key = 'other'
        else:
            key = str(round(phi))
        if any(key in self.__equiv_spots_no_superpos[dom] for dom in domains):
            return key
        return 'other'

    def __build_domains(self):
        """
        Returns the viperleed.Lattice(s) with self.superlattices matrices
        """
        # Create dummy surface lattice just to get the reciprocal basis
        surf = gl.Lattice(self.__parameters['surfBasis'])

        # and get the maximum screen radius
        max_radius = gl.screen_radius(self.__parameters['eMax'],
                                      self.__parameters['screenAperture'])

        # Then prepare the actual reciprocal lattice of the first domain
        domains = [gl.Lattice(surf.reciprocal_basis, space='reciprocal',
                              group=self.__parameters['surfGroup'],
                              limit=max_radius)]

        # and work out those of the others.
        # The reciprocal-space basis of domain i is:
        #    Bi = Mi^(-T) Bb
        # with Bb the bulk reciprocal basis, and Mi the superlattice matrix
        # of domain i, i.e.,
        #   Mi = M0 Gi
        # where Gi is the operation (of the bulk group) that creates domain i.
        # Thus
        #   Bi = (M0 Gi)^(-T) Bb = Gi^(-T) M0^(-T) Bb = Gi^(-T) B0
        # However, when transforming the basis, Gi needs to be expressed
        # in the coordinate system of the SURFACE, i.e.,
        #   Gi = Breal0 Gi_absolute Breal0^(-1)
        #      = Breal0 Brealb^(-1) Gi_bulk Brealb Breal0^(-1)
        #      = superlattice_0 Gi_bulk superlattice_0^(-1)
        superlattice = self.superlattices[0]
        inv_superlattice = np.linalg.inv(superlattice)
        ops_t = [np.linalg.multi_dot((superlattice,
                                      op,
                                      inv_superlattice))
                 for op in self.operations]
        ops = [np.linalg.inv(op).T for op in ops_t[1:]]  # skip first one
        domains.extend([domains[0].transform(op, as_copy=True)
                        for op in ops])
        return domains

    def __find_domain_operations(self):
        """
        Finds the symmetry operations of the bulk lattice that give distinct
        domains in LEED.
        NB: this function gives different results than what one would get from
        LEEDPat, as we're interested also in the symmetry relations between the
        intensities of the spots, while LEEDPat cares only about the presence
        or not of any spot.

        Returns
        -------
        list of operations

        -------
        """
        # The current version is based on the concept of co-sets of a group.
        # Given a group G and a subgroup H, the left co-set of H with respect
        # to the group operation g of G is
        #           gH = {g*h : h in H}.
        # Additionally, we take into account that each element of G is found in
        # exactly only one co-set (e.g., H is the identity co-set).
        #
        # The operations g_i that generate distinct co-sets are those that will
        # generate distinct lattices

        def __array_2_tuple(arr):
            """
            Convenience function that is used to convert a 2x2 array to a 2x2
            tuple
            """
            return tuple(map(tuple, arr))

        # 1) project the operations from the surface group to the bulk; also
        #    rounding to integers
        project_to_bulk = np.linalg.inv(self.__parameters['SUPERLATTICE'])
        surf_ops = tuple(
            op.round().astype(int)
            for op
            in self.groups['surf'].transform(project_to_bulk)
            )

        # 2) keep track of the operations of the bulk group that are already in
        #    a co-set, and of the group operations giving distinct co-sets
        coset_ops = set()
        _ops = []

        # 3) run through the bulk operations, adding the operations of new
        #    co-sets to the set above
        bulk_ops = self.groups['bulk'].group_ops(include_3d=True)

        for bulk_op in bulk_ops:
            if bulk_op in coset_ops:
                continue
            _ops.append(bulk_op)
            coset = set(__array_2_tuple(np.dot(bulk_op, surf_op))
                        for surf_op in surf_ops)
            coset_ops.update(coset)

        return _ops

    def __get_spot_equivalence(self):
        """
        Determines which of the LEED beams of the domains belong to the same
        equivalence class under the symmetry operations of the domain itself,
        i.e., it determines the 'star' of each of the beams.
        Returns a list of dictionary of dictionaries, one list element per each
        domain. Each key in the outer dictionary is either 'norm', the angle
        in degrees of a mirror direction (with respect to the first real-space
        lattice vector of the first domain BETTER WRT BULK??), or 'other'.
        These keys are useful for selecting equivalent spots when the primary
        beam direction is, respectively, normal to the surface, contained in a
        mirror plane, or generic.

        Returns
        -------
        list of dicts, each one
            keys : str
                'norm' and 'other' keys are always present. In addition, there
                are as many keys as self.special_directions, each one is the
                angle in degrees between the mirror direction and the first
                real-space basis vector. The angles can only be a subset of:
                '0', '30', '45', '60', '90', '120', '135', '150'
            values : dict
                keys : tuple
                    one key per each index in self.hk
                values: set of tuples
                    all beam indices symmetry-equivalent to key, including key,
                    i.e., what's known as 'the star' of the beam in key
        """
        # Will create several dictionaries, labeled depending on the beam
        # incidence directions. There always will be one for 'norm' (normal)
        # incidence, as many as there are special_directions, each of
        # which will be indexed by the angle between the special direction
        # and the first basis vector, and one for 'other'. This makes it fast
        # to later select which of the equivalence relations to choose.
        # Since the beam equivalence dictionaries are the same for all domains,
        # work on the first one only , i.e., self[0], in integer-index notation,
        # and later on translate stuff to the other domains
        all_operations = self[0].group.group_ops()
        a_angle = gl.orientation(self[0].real_basis[0], zero_pi=False)
        
        # Prepare the dict keys:
        labels = ['norm', 'other']
        operations = [all_operations,        # Normal incidence -> all
                      (all_operations[0],)]  # Generic -> only identity
        # Now go through the mirror directions for the other keys.
        # For a beam along the mirror, the only operations that remain are
        # identity and the mirror itself
        for op, direction in zip(all_operations, self[0].special_directions):
            if direction is None:  # the operation is a rotation
                continue
            phi = gl.orientation(direction, zero_pi=False)
            labels.append(round((phi - a_angle) % 180))
            operations.append((all_operations[0], op))
        
        # Now use the labels and the operations found above to find the star of
        # each beam of the first domain in all cases
        beams_dict_first = {}
        for label, ops in zip(labels, operations):
            # Transform all the beams with all the operations
            hk_transformed = np.einsum('ilm,mj->jil', ops, self[0].hk.T)

            # convert all beams to tuples so they can be keys for the dictionary
            hk_tuples = self.__beam_array_to_tuples(self[0].hk)
            
            # and convert to tuples also the transformed beams,
            # also using a set to remove duplicates
            beams_dict_first[label] = {
                k: set(self.__beam_array_to_tuples(v, axis=1))
                for k, v in zip(hk_tuples, hk_transformed)
            }
        return self.__beams_dict_to_other_domains(beams_dict_first)
    
    def __beam_array_to_tuples(self, indices, axis=None):                       ## WILL MOVE THIS OUT
        """
        Converts an array of beam indices into a zip object, that will return
        tuples when iterated over

        Parameters
        ----------
        indices : numpy.ndarray
            An array containing a list of indices. Can be either of shape (N, 2)
            or shape (2, N). The output will always be a list of tuples,
            independent of the shape of the input
        axis : 0, 1, or None
            Which axis contains the 2-tuples. Use axis=0 if indices[i] is the
            i-th tuple, axis=1 if indices[:, i] is the i-th tuple. If None or
            omitted, the axis is inferred from which of the dimensions is equal
            to two, unless both are. In that case axis is mandatory.

        Returns
        -------
        zip-object
        """
        # Make sure we get an array. It would be possible to also do this with
        # other array-like objects but it's not implemented
        if not isinstance(indices, np.ndarray):
            raise TypeError("Need a numpy array as input")
        if all(length != 2 for length in indices.shape):
            raise ValueError("Invalid shape of index array. Expected (2, N)"
                                 f" or (N, 2), found {indices.shape}")
        if axis is None:
            # determine which one is the right axis
            if indices.shape[0] == 2 and indices.shape[1] != 2:
                axis = 0
            elif indices.shape[0] != 2 and indices.shape[1] == 2:
                axis = 1
            else:
                raise RuntimeError("Cannot determine automatically which is the"
                                   "correct axis, as indices.shape is (2, 2). "
                                   "Provide the correct axis with the axis "
                                   "optional argument")
        if axis == 0:  # Shape == (2, N)
            return zip(indices[0], indices[1])
        # Shape == (N, 2)
        return zip(indices[:, 0], indices[:, 1])
    
    def __get_extinct(self):
        """
        For each domain, finds the beams extinct due to glide symmetry, and
        populates dictionaries with the in-plane directions of the primary
        beam that makes them extinct
        """
        group = self.groups['surf'].group
        # Like for __get_spot_equivalence, do the calculation on the first
        # domain, then extend to the others by relabeling
        if 'g' not in group:
            # no glide, no need to bother
            return [{'norm': [], 'other': []}]*len(self)
        
        # get boolean arrays that pick the extinct spots along the [1 0] and
        # [0 1] directions (for the first domain, but they're the same for
        # the others)
        extinct_10 = (self[0].hk[:, 1] == 0) & (self[0].hk[:, 0] % 2 == 1)
        extinct_01 = (self[0].hk[:, 0] == 0) & (self[0].hk[:, 1] % 2 == 1)
        
        beams_dict_first = {'other': []}
        # pg, pmg, p4g are the only options, and exist only for square
        # or rectangular lattices, so the angles are only 0 and/or 90
        if '[1 0]' in group:
            beams_dict_first['norm'] = self[0].hk[extinct_10]
            beams_dict_first[0] = self[0].hk[extinct_10]
        elif '[0 1]' in group:
            beams_dict_first['norm'] = self[0].hk[extinct_01]
            beams_dict_first[90] = self[0].hk[extinct_01]
        else:
            beams_dict_first['norm'] = self[0].hk[extinct_10 | extinct_01]
            beams_dict_first[0] = self[0].hk[extinct_10]
            beams_dict_first[90] = self[0].hk[extinct_01]
        return self.__beams_dict_to_other_domains(beams_dict_first)

    def __beams_dict_to_other_domains(self, beams_dict_first):
        """
        Converts a beams dictionary from the first domain into a list of beams
        dictionaries for each domain. This is done by determining angular
        offsets between domains, restricting to 0...pi, and building the offset
        dictionaries. At the same time, we also convert the integer domain
        indices into fractional bulk indices via the superlattice matrices
        
        Parameters
        ----------
        beams_dict_first : dict
            keys : str or int
                can be 'norm', 'other' or integers with the angles of some
                special directions
            values : list-like or dict
                can either be a list of integer hk values of the first domain,
                or a dictionary of the form {hk0: {hk0, hk1, ...}, ...}

        Returns
        -------
        list of dict
            one list element for each of the domains, each dict has the same
            format as the one passed as parameters, except for the fact that
            keys are all strings, and angles are adjusted to all refer to the
            first lattice vector of the first domain. The contents of the
            dictionaries are the same as passed, but converted to be the
            numerator of the fractional indices with respect to the bulk
        """
        offsets = self.angular_offsets(zero_pi=True)
        beams_dicts_all_domains = []
        mu = int(abs(round(np.linalg.det(self.superlattices[0]))))
        for offset, superlattice in zip(offsets, self.superlattices):
            ddict = {}
            for label, beams in beams_dict_first.items():
                # set up the transformation matrix that gives fractional
                # indices in the bulk basis from the integer indices of
                # each domain
                transform = np.linalg.inv(superlattice).T

                # it is more convenient (faster) to still store only the
                # numerator of the indices as tuples, as this limits numerical
                # errors. The fractional indices can be retrieved when needed
                # by dividing by the determinant of the superlattice of the
                # first domain
                transform = (mu*transform).round().astype(int)
                bulk_beam_dict = self.__beams_to_bulk(beams, transform)
                if label in ['norm', 'other']:
                    ddict[label] = bulk_beam_dict
                else:
                    ddict[str(round((label + offset) % 180))] = bulk_beam_dict
            beams_dicts_all_domains.append(ddict.copy())
        return beams_dicts_all_domains

    def __beams_to_bulk(self, beams, transform):
        """
        Take either a list [hk0, hk1, ...] or a dict of the form
        {hk0: {hk1, hk2, ...}} with hk integer indices relative to one domain,
        and transform them to a list or a dict, respectively, with fractional
        indices all over.
        """
        # In case we have a dict, extract beams from the keys (one each key)
        # as well as those from the values, i.e., beams of the star of key
        if isinstance(beams, dict):
            k, v = zip(*beams.items())
            # pack them into a flat list, as this allows to run a dot product
            # in numpy that makes calculations much faster, despite the additional
            # work to unpack/re-pack stuff
            flattened_beams = list(itertools.chain(k, *v))
        elif len(beams) == 0:
            return beams
        else:
            flattened_beams = beams

        # transform the beams. For some reason, einsum is faster than dot
        transformed_beams = np.einsum('ij,jk', flattened_beams, transform)

        # Now transform them back to a list of tuples
        transformed_beams = list(self.__beam_array_to_tuples(transformed_beams,
                                                             axis=1))
        if not isinstance(beams, dict):
            return transformed_beams

        # When a dict was passed, we need to split the 
        # beams once again into keys and values
        k_transf = transformed_beams[:len(k)]
        v_transf = transformed_beams[len(k):]

        # and figure out how long each of the values used to be, so they can
        # be split again correctly among the various keys
        split_idx = list(itertools.accumulate([0, *(len(i) for i in v)]))

        # Do the splitting, also converting again to set
        v_transf = [set(v_transf[i:j])
                    for i, j in zip(split_idx, split_idx[1:])]

        # and recreate the dictionary
        return dict(zip(k_transf, v_transf))


class LEEDEquivalentBeams:                                                      ## TODO: fix docstring
    """
    This class is just a processor for finding beams that are equivalent among
    the ones used for instantiation. The beams originate from the same bulk,
    whose reciprocal-space basis is also passed during instantiation.

    The class is instantiated with one or more beam dictionaries lists. Each of
    the beam dictionaries in the list represents a 'building block', e.g., the
    domains originating from symmetry or different structural domains.
    Each of the dictionaries should have the following structure:
    keys : tuple
        each key is a beam index (with respect to the basis passed) of a LEED
        beam
    values : set of tuples
        list of beams equivalent to key
    In addition a list of glide-extinct beams can also be passed upon
    instantiation. If passed, it should have the same length as the domains
    dictionaries.
    
    Alternatively, also list of LEEDEquivalentBeams instances can be passed in
    the constructor, in which case the information will be gathered from them,
    and there is no need to pass the bulk_basis or the lists of extinct beams
    
    The primary goal of the class is to combine all the dictionaries given as
    input into new data structures that contain the beam equivalences when all
    the domains given upon instantiation are combined in an incoherent fashion
    
    Since the calculations are relatively slow, and the combinations are many,
    it's a good idea to cache instances with a hash that is computed such
    that it is unique for the geometry considered. This gives speedups of more
    than a factor 100 upon re-using an already calculated geometry
    
    This class is intended only for internal use. TRUE???
    """

    hash_keys = ('basis', 'superlattice', 'domain_ids', 'angle_key')

    __cache = {}
    def __init__(self, domains, **kwargs):
        # Do some checking of the parameters passed
        # see if the domains passed are all instances of LEEDEquivalentBeams
        if all(isinstance(dom, LEEDEquivalentBeams) for dom in domains):
            # check that the elements passed are consistent with one another,
            # i.e. that the lattice bases are compatible
            if not all(np.allclose(dom.basis, domains[0].basis)
                       for dom in domains):
                raise ValueError("LEEDEquivalentBeams: domains have different"
                                 "bulk bases, and cannot be combined")
            # In this case, treat the current instance as a superposition
            # of the inputs. This allows to treat different STRUCTURES, each
            # on the same bulk, and each possibly containing several SYMMETRY-
            # related domains
            basis = domains[0].basis
            extinct_lists = [dom.extinct for dom in domains]
            domains = [dom.equivalent_beams_dict for dom in domains]

        elif not all(isinstance(dom, dict) for dom in domains):
            # The only other option is passing a list of beam-equivalence
            # dictionaries, as well as all the (now mandatory) parameter basis
            raise TypeError("LEEDEquivalentBeams: only list of dictionaries or "
                            "list of LEEDEquivalentBeams are acceptable. Not "
                            "possible to use mixed list")
        else:
            try:
                basis = kwargs['basis']
            except KeyError:
                raise ValueError("LEEDEquivalentBeams: missing mandatory basis"
                                 "parameter")
            extinct_lists = kwargs.pop('extinct_lists', []*len(domains))

        if np.shape(basis) != (2, 2):
            raise ValueError("LEEDEquivalentBeams: invalid bulk_basis "
                             + f"{basis}. ".replace('\n', '')
                             + "Expected a 2x2 array-like")
        if len(extinct_lists) != len(domains):
            raise ValueError("LEEDEquivalentBeams: incompatible number of "
                             + f"domains ({len(extinct_lists)}) found in "
                             + f"extinct_lists. Expected {len(domains)}")
        domain_ids = kwargs.get('domain_ids', range(len(domains)))
        
        self.__hash_dict = {}      # set by self.__update_hash
        
        # re-prepare the kwargs to update the hash dictionary, updating values
        # that may have changed during this initialization
        kwargs['basis'] = basis
        kwargs['domain_ids'] = domain_ids
        self.__update_hash(**kwargs)

        if self.is_cached:
            # skip all the calculations, and take the attributes from the cached
            # object
            cached = self.__cache[self.hash]
            self.__basis = cached.basis
            self.__eq_beams_dict = cached.equivalent_beams_dict
            self.__extinct = cached.extinct
            self.__indexed_beams = cached.indexed_beams
            return None

        # if never calculated before, or hash cannot be determined due to lack
        # of input, calculate again. If it can be hashed, cache self
        self.__basis = basis
        self.__eq_beams_dict = {}  # set in __build_beam_equivalence_dict
        self.__extinct = []        # set in __index_beams
        beam_groups = self.__build_beam_equivalence_dict(domains)
        beam_groups = self.__sort_beams(beam_groups)
        self.__indexed_beams = self.__index_beams(beam_groups, domains,
                                                  extinct_lists, domain_ids)
        if self.hash:
            self.__cache[self.hash] = self

    @staticmethod
    def clear_cache():
        """
        Completely clears the hash table of LEEDEquivalentBeams instances.
        This may be useful in case a completely new bulk structure is loaded,
        in case memory usage starts being an issue.
        """
        LEEDEquivalentBeams.__cache = {}

    @property
    def basis(self):
        """
        Basis vectors as a 2x2 iterable. a = basis[0], b = basis[1]
        """
        return self.__basis

    @property
    def extinct(self):
        """
        List of truly extinct beams, each is a tuple. Beams are truly extinct
        if they do not overlap, or if they originate from the superposition
        of extinct beams
        """
        return self.__extinct

    @property
    def equivalent_beams_dict(self):
        """
        Returns
        -------
        dict
            keys : tuple
                beam i
            values : set of tuples
                beams equivalent to beam i, taking the superposition of domains
                into account
        """
        return self.__eq_beams_dict

    @property
    def indexed_beams(self):
        return self.__indexed_beams

    @property
    def hash(self):
        """
        Computes the hash of the geometry defined during instantiation
        """
        if not self.__hash_dict:
            return 0
        return hash(tuple(self.__hash_dict.values()))

    @property
    def is_cached(self):
        return self.hash and (self.hash in self.__cache)

    def __update_hash(self, **kwargs):
        missing = [key for key in self.hash_keys if key not in kwargs]
        if missing:
            warning(f"LEEDEquivalentBeams: missing {missing}. No hash possible")
            return None
        self.__hash_dict = kwargs
        for k, v in self.__hash_dict.items():
            if k in ('basis', 'superlattice'):
                v = zip(*v)
            if k in ('basis', 'superlattice', 'domain_ids'):
                self.__hash_dict[k] = tuple(v)

    def __build_beam_equivalence_dict(self, beams_by_domain):
        """
        Parameters
        ----------
        beams_by_domain : list of dict
            Each dict is of the form
            key : tuple
                beam j of domain i
            value : set of tuples
                beams equivalent to beam j, possibly only considering beams
                of the domain, and certainly without accounting for
                superposition between domains

        Returns
        -------
        list of sets of tuples
            each of the elements of the list, is the collection of all beams
            that are equivalent to one another as a result of the superposition
            of the domains
            NB: this method also sets the instance attribute __eq_beams_dict,
                i.e., a dictionary of {beam: {beams equivalent to beam}}
        """
        # store a deepcopy of the dictionary, as later on we will pop some
        # of the elements, and we don't want to screw with the input
        beams_by_domain_copy = copy.deepcopy(beams_by_domain)
    
        # Flatten the list of all beams, keeping only uniques
        flat_beams = set(beam for beams in beams_by_domain for beam in beams)
        
        # Now figure out which of the beams are symmetry equivalent
        # taking superposition of spots into account:
        # spots originating from beams that are equivalent within each domain,
        # are equivalent only if all domains contribute with equivalent beams 
        # in all spots
        #
        # For example (symmetry domains on hexagonal bulk):
        #   dom1: (1 0), (-1 0), (1 -1), (-1 1) equivalent
        #   dom2: (1 0), (-1 0), (0 -1), (0 1)  equivalent
        #   dom3: (1 0), (-1 0)                 equivalent
        #   --> (1 0) and (-1 0) are equivalent
        #
        #   dom1: (1 0), (-1 0), (1 -1), (-1 1)  equivalent
        #   dom2:                (1 -1), (-1 1)  equivalent
        #   dom3: (0 1), (0 -1), (1 -1), (-1 1)  equivalent
        #   --> (1 -1) and (-1 1) are equivalent, but are
        #       not equivalent to [(1 0), (-1 0)]
        #
        # Another example (structural domains on square bulk):
        # p(2x2)-pmm + c(2x2)-pm[1 0] -- take spot (1 1)
        #   
        #   p(2x2): (1 1), (1 -1), (-1  1), (-1 -1)  equivalent
        #   c(2x2): (1 1), (1 -1)                    equivalent
        #   --> (1 1) and (1 -1) are equivalent
        #
        #   p(2x2): (1 1), (1 -1), (-1 1), (-1 -1)   equivalent
        #   c(2x2):                (-1 1), (-1 -1)   equivalent
        #   --> (-1 1) and (-1 -1) are equivalent, but are
        #       not equivalent to [(1 1), (1 -1)]
        beam_equivalence = []
        for beam in flat_beams:
            # from each structure, if there is a beam <beam>, take the list of all
            # those equivalent to it.
            # Example: beam = (1 1)
            #   -> take [[(1 1), (1 -1), (-1 -1), (1 -1)],  from p(2x2)
            #            [(1 1), (1 -1)]]                   from c(2x2)
            beam_sets = [beams_dict[beam]
                         for beams_dict in beams_by_domain_copy
                         if beam in beams_dict]
            if beam_sets:
                # if there are beams to process in the list, take the set
                # intersection, i.e., find all those in common to all structures
                common_beams = set.intersection(*beam_sets)
                
                # now "mark as processed" in all the structures the beams coming
                # from the intersection by removing them, and set the correct
                # keys of beam_equivalence
                for processed_beam in common_beams:
                    for unprocessed_beams in beams_by_domain_copy:
                        unprocessed_beams.pop(processed_beam, None)
                    if processed_beam in self.__eq_beams_dict:
                        raise KeyError("TEMP CHECK: setting multiple times the same key!")
                    self.__eq_beams_dict[processed_beam] = common_beams
                beam_equivalence.append(common_beams)
        return beam_equivalence

    def __sort_beams(self, beam_groups):
        """
        Sort beams given as a list of iterables. Each of the elements in the
        list is treated as a group of equivalent beams
        """
        # sort within each equivalence group and by energy
        return sorted(
            (sorted(beams, key=self.__sort_hk) for beams in beam_groups),
            key=self.__sort_energy
        )
    
    def __index_beams(self, beam_groups, beams_by_domain, extinct, domain_ids):
        """
        Given the (sorted) list of beam groups, assign to each of the
        groups one index. Also, determine which of the original domains
        contribute to the overlapped spots, and which of these contributions
        come from extinct beams. The domains (both in the overlapping and in
        the extinct lists) are labeled according to the domain_ids given
        NB: this method also sets up the __extinct instance attribute, that
            contains all the beams that are truly extinct, as a result of the
            superposition of extinct beams

        Parameters
        ----------
        beam_groups : iterable of iterables of tuples
            List of beam groups, already sorted
        beams_by_domain : list of iterables of tuples
            each entry is a domain, and contains all beams of the domain
        extinct : list of tuples
            Each entry in the list contains the beams that are extinct in each
            domain
        domain_ids : iterable
            contains names for the domains. Typically would be integers
        """
        
        indexed_beams = []
        for i, beams in enumerate(beam_groups):
            for beam in beams:
                # find which domains overlap
                overlapping = [d
                               for d, domain_beams in enumerate(beams_by_domain)
                               if beam in domain_beams]
                group_idx = i
                
                # figure out whether the beam is extinct in all the structures
                # that overlap, in which case the index goes negative
                extinct_domains = [d for d in overlapping if beam in extinct[d]]
                n_extinct = len(extinct_domains)
                if n_extinct == len(overlapping) and n_extinct > 0:
                    group_idx *= -1
                    self.__extinct.append(beam)
                indexed_beams.append((beam, group_idx,
                                      [domain_ids[d] for d in overlapping],
                                      [domain_ids[d] for d in extinct_domains]))
        # This format is not great. Since I'm always using it unzipped, it may
        # be worth just returning it unzipped in the first place, maybe as
        # a dictionary just to have some reasonable names, like 'beams',
        # 'groups', 'overlap domains', 'extinct domains'
        return indexed_beams

    def __sort_hk(self, index):
        sortH, sortK = index
        return -sortH-sortK, -sortH
    
    def __sort_energy(self, indices):
        # assumes that the indices passed represent beams that are equivalent to
        # one another, i.e., they all have the same length
        g = np.dot(indices[0], self.basis)
        # sort by energy, i.e., by ||g||^2:
        return g[0]**2 + g[1]**2

class LEEDsubpattern():
    """
    --> I originally intended to use this guy for the
         determination of beam equivalence and
         handling of hovering annotations
    """
    def __init__(self, beams, symBeams, names, domain=1, color='k',
                 alpha=None, marker='o', sizeScale=1, overlapDoms=None):
        if not all([len(beams) == len(x) for x in [symBeams, names]]):
            raise ValueError('Input shape mismatch. The length of symBeams'
                             'and/or _names differs from the one of beams.')
        if not isinstance(domain, int):
            raise ValueError("domain must be an integer.")

        self.beams = beams
        self.rotBeams = self.beams
        self.symmetricBeams = symBeams
        self.names = names
        self.domain = domain
        if alpha is None:
            self.color = np.array([mpl_colors.to_rgba(color, alpha=1)])
        else:
            self.color = np.array([mpl_colors.to_rgba(color, alpha=alpha)])
        self.marker = marker
        self.sizeScale = sizeScale
        self.overlappingDomains = overlapDoms

    def transformCoords(self, transf):
        if np.shape(transf) == (2, 2):
            self.rotBeams = np.dot(self.beams, transf)
        else:
            raise


class Woods():
    common = {'p(1\u00d71)', 'p(1\u00d72)', 'p(2\u00d71)', 'p(2\u00d72)',
              'p(3\u00d71)', 'p(3\u00d72)', 'p(3\u00d73)', 'c(2\u00d72)',
              'c(4\u00d74)', 'c(6\u00d72)', 'c(8\u00d72)'}
    examples = {
        'Oblique': common,
        'Square': common | {'c(4\u00d72)',
                            'p(\u221a2\u00d7\u221a2)R45' + degrees,
                            'p(\u221a5\u00d7\u221a5)R26.6' + degrees,
                            'p(2\u221a2\u00d7\u221a2)R45' + degrees,
                            'c(3\u221a2\u00d7\u221a2)R45' + degrees,
                            'c(5\u221a2\u00d7\u221a2)R45' + degrees},
        'Rectangular': common,
        'Hexagonal': common | {'c(4\u00d72)',
                               'p(\u221a3\u00d7\u221a3)R30' + degrees,
                               'p(\u221a7\u00d7\u221a7)R19.1' + degrees,
                               'p(2\u221a3\u00d72\u221a3)R30' + degrees},
        'Rhombic': common,
        }
    
    def woodsToMatrix(self, woods, bulk):
        parsed = self.parseWoods(woods)
        if parsed is None:
            return None
        g1 = parsed[1]
        g2 = parsed[2]
        alpha = np.radians(parsed[3])
        R1 = np.linalg.norm(bulk[0])
        R2 = np.linalg.norm(bulk[1])
        q = R2/R1
        omega = np.arccos(np.dot(bulk[0], bulk[1])/(R1*R2))
        
        m = np.array([[g1*np.sin(omega-alpha), g1*np.sin(alpha)/q],
                      [-g2*q*np.sin(alpha), g2*np.sin(omega+alpha)]])
        m = m/np.sin(omega)
        
        if parsed[0] == 'c':
            m = np.dot([[1, 1], [-1, 1]], m)/2
        
        if self.isCommensurate(m):
            m = np.array([int(np.round(mij)) 
                          for mij in m.ravel()]).reshape(m.shape)
        else:
            m = None  # incommensurate
        return m
    
    def parseWoods(self, woods):
        if not isinstance(woods, str):
            return None
        
        reWoods = re.compile(
            r'''^(?P<prefix>[pc])                # * primitive or centered
            \(                                   # * open parenthesis
            (?P<g1>\d+)?                         # * direction1, integer part
            (\u221a(?P<g1rt>\d+))?               # * direction1, radical part
            \u00d7                               # * times
            (?P<g2>\d+)?                         # * direction2, integer part
            (\u221a(?P<g2rt>\d+))?               # * direction2, radical part
            \)                                   # * close parenthesis
            ((R(?P<alpha>\d+(\.\d+)?))\u00b0)?$  # * rotation angle
            ''', re.VERBOSE)
        # notice that the ^ and $ anchors make sure that the string is 
        # matched as a whole
        
        # check if it matches the full woods
        m = reWoods.match(woods)
        if m is not None:
            w = m.groupdict()
            g1 = 1
            g2 = 1
            if w['g1'] is not None:
                g1 *= float(w['g1'])
            if w['g1rt'] is not None:
                g1 *= np.sqrt(float(w['g1rt']))
            if w['g2'] is not None:
                g2 *= float(w['g2'])
            if w['g2rt'] is not None:
                g2 *= np.sqrt(float(w['g2rt']))
            if w['alpha'] is not None:
                alpha = float(w['alpha'])
            else:
                alpha = 0
            return [w['prefix'], g1, g2, alpha]
        return None
    
    def matrixToWoods(self, m, bulk):
        m = np.array(m)
        
        pc = self.primitiveOrCentered(m, bulk)
        if pc:  # matrix is woods representable as primitive or centered
            toFormat = []
            for gSq in [pc[1]**2, pc[2]**2]:
                gSq = np.round(gSq)
                (g2, grt) = self.squareToProdOfSquares(gSq)
                integer = str(int(round(np.sqrt(g2))))
                
                dirStr = '' #format the direction in here
                if grt > 1: # insert root part
                    dirStr = '\u221a' + str(int(grt))
                if dirStr == '': # if there is no root part, always insert 
                                 # the integer part
                    dirStr = integer
                else:
                    if integer != '1': # otherwise place it in only if it's 
                                       # not 1
                        dirStr = integer + dirStr
                
                toFormat.append(dirStr)
            woods = '{}({})'.format(pc[0], '\u00d7'.join(toFormat))
            cosAlpha = pc[3]
            if np.abs(cosAlpha) > 1e-3 and 1-np.abs(cosAlpha) > 1e-3:
                #angle not 0, 90 nor 180
                alpha = np.round(np.degrees(np.arccos(cosAlpha)),
                                 decimals = 1)
                woods += 'R' + str(alpha) + degrees
            return woods
        return None
    
    def isCommensurate(self, m, eps=1e-3):
        if m is None:
            return False
        
        mu = np.linalg.det(m)
        if np.round(mu) == 0.0:  # matrix is singular
            return False

        if np.abs(mu/np.round(mu) - 1) > eps:  # determinant is not integer
            return False
        
        # now check whether any element is non-integer
        for mij in m.ravel():
            if np.round(mij) == 0.0:
                if abs(mij)/np.sqrt(np.abs(mu)) > eps:
                    return False
            elif np.abs(mij/np.round(mij) - 1) > eps:
                return False
        return True
    
    def isRepresentable(self, m, basis):
        transform = np.dot(m, basis)
        nBasis = np.linalg.norm(basis, axis=1)
        nTransf = np.linalg.norm(transform, axis=1)
        g1 = nTransf[0]/nBasis[0]
        g2 = nTransf[1]/nBasis[1]
        mu = np.abs(np.linalg.det(m))
        
        return abs(mu/(g1*g2) - 1) < 1e-8
    
    def primitiveOrCentered(self, m, basis):
        invT = np.array([[1, -1], [1, 1]])
        
        primitive = self.isRepresentable(m, basis)
        ctrd = self.isRepresentable(np.dot(invT, m), basis)
        if primitive:
            prefix = 'p'
        elif ctrd:
            prefix = 'c'
            m = np.dot(invT, m)
        else:
            return False
        
        nBasis = np.linalg.norm(basis, axis=1)
        transform = np.dot(m, basis)
        nTransf = np.linalg.norm(transform, axis=1)
        g1 = nTransf[0]/nBasis[0]
        g2 = nTransf[1]/nBasis[1]
        cosAlpha = np.dot(transform[0], basis[0])/(nTransf[0]*nBasis[0])
        
        return (prefix, g1, g2, cosAlpha)
    
    def squareToProdOfSquares(self, number):
        # takes number, finds all prime factors, returns a tuple, first 
        # element is a product of all primes showing up an even number of 
        # times, the second one the rest. Useful to turn, e.g., sqrt(12) 
        # into 2sqrt(3)
        
        factors = list(self.primeFactors(number))
        if not factors:
            factors = [1]
        uniqueFact = sorted(list(set(factors)))
        countFact = [((factors.count(fac) // 2)*2, factors.count(fac) % 2)
                      for fac in uniqueFact]
        (pow2, restPow) = zip(*countFact)
        (squares, remainders) = zip(*[(fact**pow, fact**rem)
                                      for (fact, pow, rem)
                                      in zip(uniqueFact, pow2, restPow)
                                      ])
        
        return (np.prod(squares), np.prod(remainders))
    
    def primeFactors(self, n):
        f = 2
        increments = itertools.chain(
                                  [1, 2, 2],
                                  itertools.cycle([4, 2, 4, 2, 4, 6, 2, 6])
                                  )
        for incr in increments:
            if f*f > n:
                break
            while n % f == 0:
                yield f
                n //= f
            f += incr
        if n > 1:
            yield n
